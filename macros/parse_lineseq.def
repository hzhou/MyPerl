fncode: end_of_lineseq(int token)
    $if token==0 || token == '}'
        return 1
    return 0

fncode: f_parse_lineseq
    $return_type YYSTYPE
    $global yychar
    $local YYSTYPE T
    T = Nullop
    $while 1
        yychar = yylex()
        $if end_of_lineseq(yychar)
            last
        $map P, FORMAT, SUB, MYSUB, PACKAGE, USE
        $else
            $call yy_optional, T0, LABEL
            $map P, IF, UNLESS 
            $map P, WHILE, UNTIL, FOR, '{'
            $elif yychar=='{'
                $call block
            $elif yychar==';'
                $if T0!=Nullch
                    T1 = newOP(OP_NULL, 0)
                    T0 = newSTATEOP(0, T0, T1)
                $else
                    T0 = Nullop
                    PL_copline = NOLINE
                PL_expect = XSTATE
            $else
                yyunlex()
                $call sideff
                $call yy_expect, ';'
                T0 = newSTATEOP(0, T0, T1)
                PL_expect=XSTATE
            T = append_list(OP_LINESEQ, (LISTOP*) T, (LISTOP*) T0)
            PL_pad_reset_pending = TRUE;
            $if T && T0
                PL_hints |= HINT_BLOCK_SCOPE

    return T

    # -------------
    subcode: P(T)
        $case yychar==$(T)
            $call $(T)

    # --------------
    subcode: IF
        T0 = newSTATEOP(0, T0, T1)
    subcode: UNLESS
        T0 = newSTATEOP(0, T0, T1)
    subcode: WHILE
    subcode: UNTIL
    subcode: FOR
    subcode: block
    # --------------
    subcode: sideff
        T1 = f_parse_expr()

        yychar = yylex()
        $(set:cond) join, ' || ', yychar=*
            IF, UNLESS, WHILE, UNTIL, FOR
        $if $(cond)
            $call tail_exp
        $call yy_expect, ';'

        subcode: tail_exp
            tn_tail = yychar
            T3 = f_parse_expr()
            $if tn_tail == IF
                T1 = newLOGOP(OP_AND, 0, T3, T1)
            $elif tn_tail == UNLESS
                T1 = newLOGOP(OP_OR, 0, T3, T1)
            $elif tn_tail == WHILE
                T1 = newLOOPOP(OPf_PARENS, 1, scalar(T3), T1)
            $elif tn_tail == UNTIL
                T1 = newLOOPOP(OPf_PARENS, 1, invert(scalar(T3)), T1)
            $elif tn_tail == FOR
                T1 = newFOROP(0, Nullch, FOR, Nullop, T3, T1, Nullop

    # ---- decl ----
    subcode: FORMAT
        &call yy_seq, startformsub, WORD?, block
            newFORM($(T1),$(T2),$(T3))

    subcode: SUB
        $(if:!fn)
            $(set:fn=newATTRSUB)
        &call yy_seq, startsub, subname, THING?, subattrlist, subbody
            $(fn)($(T1),$(T2),$(T3),$(T4),$(T5))

    subcode: MYSUB
        $(set:fn=newMYSUB)
        $call SUB

    subcode: PACKAGE
        &call yy_seq, WORD?, ';'
            package($(T1))

    subcode: USE
        # I don't understand this!
        &call yy_seq, startuse, WORD, WORD, listexpr, ';'
            utilize(USE,$(T1),$(T3),$(T4),$(T5))


