subcode: _autoload
    # ref: scope.def
    $struct(CV) stash, i_file, i_start, n_vars, n_seq, op_block
    $struct(CV) int flag
    $register_prefix(cv) struct CV*

    $define(CVf_switch) 1
    $define(CVf_loop) 2
    $define(CVf_sub) 3

fncode: CV_new
    $local cv
    $allocate(1, 0) cv
    return cv

macros:
    is_top_scope: lex_stack_len==1

#---- compile time parse_reduce ----------- 
subcode: _autoload
    $global darray lex_stack: struct CV*
    $global cv_cur=NULL
    $global i_seq=0

subcode: cv_cur_wrap
    $(set:cv=cv_cur->$1)
    $(cv:n_vars) = g_local_len - $(cv:i_start)
    $(cv:n_seq)  = i_seq

subcode: cv_begin
    $if cv_cur
        $call cv_cur_wrap
    lex_stack.$push cv_cur

    stash_local = stash_new()
    cv_cur = CV_new()
    cv_cur->stash = stash_local
    cv_cur->i_file = cur_file_scope
    cv_cur->i_start = g_local_len
    $call @debug_cv_begin
    i_seq = 0

subcode: cv_close(op_block)
    $if $(op_block)->type == OP_SEQ
        f_flatten_op_list($(op_block), OP_SEQ)
        $(op_block)->type=OP_block

    cv_cur->op_block = $(op_block)
    $call cv_cur_wrap

    cv = cv_cur
    cv_cur = lex_stack.$pop
    $if cv_cur
        g_local_len = cv_cur->i_start + cv_cur->n_vars
        i_seq   = cv_cur->n_seq
        stash_local = cv_cur->stash

    $call @debug_cv_close
    $(export:cv=cv)

# ------------------
subcode: parse_init
    $call cv_begin

# -------------------
subcode: reduce_eof
    $if i_top==2
        $call cv_close, stack[i_top-1].value.op
        $if lex_stack_len!=0
            $call error, "cv scope mismatch!"
        stack[0].value.cv = $(cv)
        i_top=0
        break
    $else
        $print "EOF: i_top=$i_top"
        $call error, "Context mis-match!"

subcode:: define_parse_terms
    # T_Stmt2 precedes block
    $map op, pre, Stmt2

subcode: reduce_cv
    $call cv_close, $(block)
    $call set_atom, OP_CV, $(cv)
    i_top-=2

    # need decide whether to append T_Semi
    s = f_skip_spaces(s)

    $(set:op_cv=cur.value.op)
    $if $(type:1)==$1 :||: T_Semi, T_BOC
        # bare block
        $call shift_cur
        $call set_cur, T_Semi, 0
        continue
    $elif $(type:1)==T_BOS
        # e.g. do {...}
        $(set:op=stack[i_top-1].value.op)
        $(set:T=$(op)->type)
        $call @reduce_statement_cv1
        $call error, "cv1"
    $elif $(type:2)==T_BOS
        # e.g if(cond) {...}
        $(set:op=stack[i_top-2].value.op)
        $(set:op1=stack[i_top-1].value.op)
        $(set:T=$(op)->type)
        $call @reduce_statement_cv2
        $call error, "cv2"
    $call error, "unhandled block"

    subcode: cv1_done
        $(type:1)=T_ATOM
        $call set_cur, T_Semi, 0
        continue

    subcode: cv2_next
        i_top-=1
        cur.type = 0
        break

    subcode: cv2_done
        i_top-=1
        $call cv1_done
