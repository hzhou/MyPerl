# include: macros/requisite.def
include: macros/parse_frame.def
include: macros/parse_precedence.def
include: macros/parse_scan.def
include: macros/parse_error.def
include: macros/parse_reduce.def

include: macros/parse_resolve.def

include: macros/parse_char.def
include: macros/parse_keyword.def
include: macros/parse_number.def
include: macros/parse_string.def
include: macros/parse_word.def
include: macros/parse_var.def
include: macros/parse_bareword.def

# include: macros/parse_old.def

subcode: _autoload
    $union(VAL) n, s, op, cv

fncode: perl_parse(s_in, file_in, struct TOK* stack, i_top)
    $(set:in_perl_parse=1)
    $call parse_scan_init, s_in, file_in
    s = s_in
    $call parse_frame

    return i_top
    # ----------------
    subcode: reduce
        $(set:op_t=$(type:2))
        $if $(op_prefix:$(type:2))
            $(set:op_n=stack[i_top-2].value.n)
            $(set:op_op=stack[i_top-2].value.op)
            $(set:term=stack[i_top-1].value.op)
            $call @reduce_prefix
        $else
            $(set:op_v=stack[i_top-2].value.n)
            $(set:term1=stack[i_top-3].value.op)
            $(set:term2=stack[i_top-1].value.op)
            $call @reduce_binary
        $call error, "Don't know how to reduce"

        subcode: opT(T)
            $case $(op_t)==T_$(T)
                BLOCK

    subcode: reduce_eoc
        $(set:op_eoc=cur.value.n)
        $(set:op_boc=stack[i_top-2].value.n)
        $(set:block=stack[i_top-1].value.op)
        $call @debug_reduce_eoc
        $if $(op_eoc)==0
            $call reduce_eof
        $else
            $call @check_eoc_match, $(op_boc), $(op_eoc)
            $if $(op_eoc)=~[}\]]
                $call @check_reduce_var_index
            $if $(op_eoc)=='}'
                $call reduce_cv
            $call copy_stack, i_top-2, i_top-1
            i_top-=1
            goto lexer

    subcode: reduce_eof
        $if i_top==2
            $call copy_stack, 0, 1
            return 1
        $else
            return i_top

    subcode: reduce_postfix
        $call error, "Don't know reduce_postfix"

    # ------------------------
    # -- during match
    subcode: set_cur(type, v)
        cur.type=$(type)
        $(if:v~s_)
            cur.value.s = $(v)
        $(elif:v~op)
            cur.value.op = $(v)
        $(else)
            cur.value.n = $(v)

    # -- during match/reduction
    subcode: set_atom(op_type, v)
        cur.type=T_ATOM
        $call new_op, cur.value.op, $(op_type), $(v)

#----------------------------------------------- 
subcode: match
    # ref: parse_number/string/var/word
    $call @parse_match_cases
    $elif *s=~[({\[]
        $call set_cur, T_BOC, *s
        s++
        goto do_shift
    $elif *s=~[)}\]]
        $call set_cur, T_EOC, *s
        s++
        goto try_reduce
    $else
        tn_op=0
        # $print "f_scan_operator [%c]", s[0]
        s = f_scan_operator(s, &tn_op)
        # $print "    returns 0x%x", tn_op
        $if tn_op>0
            $call set_cur, tn_op, 0
            goto try_reduce
        $else
            $call error, "symbol not matched"

subcode: shift_boc
    $if cur.value.n == '{'
        tb_cv = 1
        &call if_atom_var, 1
            tb_cv=0
        $if tb_cv
            CV_begin()
            $call @set_cv_flags

#----------------------------------------------- 
subcode: check_eoc_match(b,e)
    $(set:p1=($(b)=='(' && $(e)==')'))
    $(set:p2=($(b)=='[' && $(e)==']'))
    $(set:p3=($(b)=='{' && $(e)=='}'))
    $if $(p1) || $(p2) || $(p3)
        # ok
    $else
        $call error, "Parentheses mismatch!"

    subcode: mismatch(open, close)
        $case $(b)=='$(open)'
            $if $(e)!='$(close)'
                $call 
