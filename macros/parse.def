# include: macros/requisite.def
include: macros/parse_frame.def
include: macros/parse_precedence.def
include: macros/parse_scan.def
include: macros/parse_error.def
include: macros/parse_reduce.def

include: macros/parse_resolve.def

include: macros/parse_char.def
include: macros/parse_keyword.def
include: macros/parse_number.def
include: macros/parse_string.def

include: macros/parse_var.def
# include: macros/parse_old.def

subcode: _autoload
    # YYSTYPE
    $union(YYVAL) n, s, op, cv
    $typedef union YYVAL YYSTYPE
    $typedef struct OP OP

subcode:: define_parse_terms
    $map atom, WORD, ATOM

fncode: perl_parse(s_in, file_in)
    $(set:in_perl_parse=1)
    $return_type struct CV*
    $local s=s_in
    $global file_src
    file_src = file_in
    # $print "s:%p, file_src: %p", s, file_src
    $call parse_frame
    return stack[0].value.cv

    subcode: reduce
        $(set:op_t=$(type:2))
        $if $(op_prefix:$(type:2))
            $(set:op_n=stack[i_top-2].value.n)
            $(set:op_op=stack[i_top-2].value.op)
            $(set:term=stack[i_top-1].value.op)
            $call @reduce_prefix
        $else
            $(set:op_v=stack[i_top-2].value.n)
            $(set:term1=stack[i_top-3].value.op)
            $(set:term2=stack[i_top-1].value.op)
            $call @reduce_binary
        $call error, "Don't know how to reduce"

        subcode: opT(T)
            $case $(op_t)==T_$(T)
                BLOCK

    subcode: reduce_eoc
        $(set:op_eoc=cur.value.n)
        $(set:op_boc=stack[i_top-2].value.n)
        $(set:block=stack[i_top-1].value.op)
        $call @debug_reduce_eoc
        $if $(op_eoc)==0
            $call reduce_eof
        $else
            $call @check_eoc_match, $(op_boc), $(op_eoc)
            $if $(op_eoc)=~[}\]]
                $call @check_reduce_var_index
            $if $(op_eoc)=='}'
                $call reduce_cv
            $call copy_stack, i_top-2, i_top-1
            i_top-=1
            cur.type=0
            break

    subcode: reduce_postfix
        $call error, "Don't know reduce_postfix"

    # ------------------------
    # -- during match
    subcode: set_cur(type, v)
        cur.type=$(type)
        $(if:v!=0)
            $(if:v~s_)
                cur.value.s = $(v)
            $(elif:v~op)
                cur.value.op = $(v)
            $(else)
                cur.value.n = $(v)

    # -- during match/reduction
    subcode: set_atom(op_type, v)
        cur.type=T_ATOM
        $call new_op, cur.value.op, $(op_type), $(v)

#----------------------------------------------- 
subcode: match
    # ref: parse_number/string/var... use grep
    $call @parse_match_cases
    $elif isword(*s)
        $call @match_v_string
        s2 = s
        s = f_scan_word(s)
        n = (int)(s-s2)
        tn_word = my_word(s2, n)
        $if !tn_word
            sv=get_sv()
            SV_copy_s(sv, s2, n)
            $call set_atom, OP_CONST, sv
        $else
            $call @parse_keyword_cases
            $call @parse_keyword_other
            $else
                $call error, "unsupported keyword $s2"
        break
    $elif *s=~[({\[]
        $call set_cur, T_BOC, *s
        s++
        break
    $elif *s=~[)}\]]
        $call set_cur, T_EOC, *s
        s++
        break
    $else
        tn_op=0
        # $print "f_scan_operator [%c]", s[0]
        s = f_scan_operator(s, &tn_op)
        # $print "    returns 0x%x", tn_op
        $if tn_op>0
            $call set_cur, tn_op, 0
        $else
            $call error, "symbol not matched"
        break

subcode: shift_boc
    $if cur.value.n == '{'
        tb_cv = 1
        &call if_atom_var, 1
            tb_cv=0
        $if tb_cv
            $call cv_begin

#----------------------------------------------- 
subcode: check_eoc_match(b,e)
    $(set:p1=($(b)=='(' && $(e)==')'))
    $(set:p2=($(b)=='[' && $(e)==']'))
    $(set:p3=($(b)=='{' && $(e)=='}'))
    $if $(p1) || $(p2) || $(p3)
        # ok
    $else
        $call error, "Parentheses mismatch!"

    subcode: mismatch(open, close)
        $case $(b)=='$(open)'
            $if $(e)!='$(close)'
                $call 
