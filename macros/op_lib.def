subcode: _autoload
    $call register_op_types
    $struct(op) op_next, op_sibling, op_ppaddr
    $struct(op) op_targ,op_type,op_seq,op_flags,op_private

    $struct(unop) class op, op_first
    $struct(binop) class op, op_first,op_last
    $struct(logop) class op, op_first,op_other
    $struct(listop) class op, op_first,op_last

    $struct(pmop) class op, op_first, op_last
    $struct(pmop) op_pmreplroot,op_pmreplstart,op_pmnext,op_pmregexp,op_pmflags,op_pmpermflags,op_pmdynflags

    $struct(svop) class op, op_sv
    $struct(pvop) class op, op_pv
    $struct(padop) class op, PADOFFSET op_padix
    $struct(loop) class op, op_first, op_last, op_redoop, op_nextop, op_lastop

    $(for:USED,TAINTED,UTF8 and 0x1-3)
        $define(PMdf_$1) $2
    $(for:RETAINT,ONCE,REVERSED,MAYBE_CONST,SKIPWHITE,WHITE,CONST,KEEP,GLOBAL,CONTINUE,EVAL,LOCALE,MULTILINE,SINGLELINE,FOLD,EXTENDED and 0x1-16)
        $define(PMf_$1) $2

#----------------------------------------------- 
subcode: register_op_types
    $fntype(op_ppaddr) OP*, void
    $(for:next,silbing,first,last,other,redoop,nextop,lastop)
        $register_name(op_$1) OP*
    $(for:targ,type,seq,flags,private and U32,U16,U16,U8,U8)
        $register_name(op_$1) $2
    $(for:replroot,replstart,next,regexp,flags,permflags,dynflags and OP*,OP*,PMOP*,REGEXP*,U16,U16,U8)
        $register_name(op_pm$1) $2
    $(for:sv,pv and SV*,char*)
        $register_name(op_$1) $2

#----------------------------------------------- 
fncode: convert(I32 type, I32 flags, OP* o)
    $if !o || o->op_type != OP_LIST
	o = newLISTOP(OP_LIST, 0, o, Nullop);
    $else
        # OP_LIST
	o->op_flags &= ~OPf_WANT;

    $call @convert_0_arg
    o->op_type = type;
    o->op_ppaddr = PL_ppaddr[type];
    o->op_flags |= flags;

    o = CHECKOP(type, o);
    if (o->op_type != type)
	return o;

    return fold_constants(o);

    subcode: convert_0_arg
        if (!(PL_opargs[type] & OA_MARK))
            null(cLISTOPo->op_first);

