include: c/regex_simple.def

subcode: _autoload
    # user need declare union type VAL
    # e.g. $union(VAL) n    -- n is the minimum type
    $struct(TOK) int type, union VAL value

macros:
    MAX_TOK_STACK: 100

# f_skip_spaces: custom function
#     which [re]loads src string
#     , and skips spaces and comments, 
#     returns NULL on EOF

subcode: parse_frame
    $if i_top == 0
        stack[0].type = T_BOC
        stack[0].value.n = 0
        i_top=1
    # ---- either setup new stack 
    #      or passed in from function parameter
    # $local struct TOK* stack, i_top
    # ----------------------
    $local struct TOK cur={0,0}
    $call @parse_init

    $(set:type=stack[i_top-$1].type)
    $(set:value=stack[i_top-$1].value)
    $local s=NULL
    $while 1
        lexer:
        $call @debug_parse
        s=f_skip_spaces(s)
        $if s==NULL
            cur.type = T_EOF
            cur.value.n = 0
            goto try_reduce
        $call @match
        $call error, "unexpected char"

        try_reduce:
        $call assert, $(is_op:cur.type)
        $call @pre_reduce

        $call check_op_context
        $if i_top<=1
            goto do_shift
        &call if_less_precedence
            $call @reduce
        $elif $(op_postfix:cur.type)
            $if cur.type==T_EOF
                $call @reduce_eof
            $elif cur.type==T_EOC
                $call @reduce_eoc
            $else
                $call @reduce_postfix

        $if !cur.type
            goto lexer
        $elif cur.type==T_EOF
            break

        do_shift:
        $if $(is_atom:cur.type)
            $call check_atom_context
        $elif cur.type==T_BOC
            $call @shift_boc
        $call shift_cur

    # -------------------------
    subcode: shift_cur
        stack[i_top++] = cur

    # -------------------------
    subcode: if_less_precedence
        $(set:p0=$(op_prec:cur.type))
        $(set:p1=$(op_prec:$(type:2)))
        $if $(p0)<$(p1) || ($(p0)==$(p1) && $(op_left:cur.type))
            BLOCK

    subcode: copy_stack(i1, i2)
        memcpy(stack+$(i1), stack+$(i2), sizeof(struct TOK))

    # ----------------------------
    subcode: check_atom_context
        $if $(is_atom:$(type:1))
            # break if resolved
            #   turn last one into op
            $call @resolve_atom_atom
            $call error, "unexpected atom"

    subcode: check_op_context
        $if $(is_op:$(type:1))
            $if $(op_prefix:cur.type)
                goto do_shift
            $else
                # break if resolved
                #   turn cur into uniop
                $(set:T=cur.type==T_$1)
                $(set:T1=$(type:1)==T_$1)
                $call @resolve_op_op
                $call error, "unexpected operator!"
        $else # $(is_atom:$(type:1))
            $if $(op_prefix:cur.type)
                $call @resolve_atom_prefix
                $call error, "unexpected unary operator"
        $call @resolve_op_other

#---------------------------------------- 
subcode: resolve_op_op
    $case $(T:EOF) && i_top==1
        # empty input
        stack[0].type = T_ATOM
        break

