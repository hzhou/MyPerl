macros:
    KEY_OTHER:: sub

subcode:: define_ops
    $call define_op, SUB

subcode:: parse_keyword_other
    $elif tn_word == WORD_sub
        $call new_op, op, OP_SUB, 0
        $call set_cur, T_BOS_HEAD, op
        goto try_reduce

subcode:: parse_bareword
    $case tn_bos_op == OP_SUB
        $call bareword_subname
        $(value:1).op->left.sv = sv
        goto lexer

subcode:: set_cv_flags
    $if $(type:1)==T_BOS_HEAD && $(value:1).op->type==OP_SUB
        cv_cur->flag = CVf_sub

subcode:: reduce_statement_cv1
    $case $(T) == OP_SUB
        sv_name = $(value:1).op->left.sv
        &call with_sv_string, sv_name
            $call add_sub, $(s), $(n), cv
        i_top -= 1
        goto lexer

# -----
subcode:: perl_init
    $global darray subs: struct CV*
    subs.$grow 10
    subs_len=1 # start at index 1 (simplify test)

subcode: add_sub(name, len, cv)
    stash_global.$set $(name), $(len), subs_len
    subs.$push $(cv)
    # printf("add sub %.*s -- %d\n", $(len),$(name),subs_len-1)

#----------------------------------------------- 
subcode:: define_ops
    $map define_op, Fcall, fcall

subcode:: parse_bareword
    $case s && *s=='('
        $call bareword_subname
        $call new_op2, op, OP_Fcall, sv, 0
        # reduce ref: parse_reduce.def
        cur.type=T_UNARY
        cur.value.op = op
        goto try_reduce

    subcode: bareword_subname
        sv = get_sv(SVt_string)
        SV_append_s(sv, "&", 1)
        SV_append_s(sv, s2, n)

#----------------------------------------------- 
subcode:: eval_op_cases
    case OP_Fcall:
        sv_name = op->left.sv
        &call with_sv_string, sv_name
            $(s)[$(n)]='\0'
            i_sub = find_global($(s))
            $if !i_sub
                $call die, "Undefined subroutine %s", $(s)
        op->left.n=i_sub
        op->type = OP_fcall
    case OP_fcall:
        i_sub=op->left.n
        cv = subs[i_sub]
        sv_arg = eval_op(op->right.op, $(CTX_LIST))
        $call run_sub
        return NULL

#---------------
subcode:: universal_vars
    $call add_universal, @ARG # @_
    $call add_universal, @RET # returns

subcode:: match_special_av
    $case s[0]=='_' && !isword(s[1])
        s++
        $call new_op2, op, OP_GLOBAL, '@', I_at_ARG

#---------------
subcode: run_sub
    &call check_file_scope
        &call check_cv_scope
            &call set_I_at_ARG, av_arg
                sv_ret = run_cv(cv, $(CTX))
                $call ret_svreg, sv_ret
                $call get_returns
    return sv_ret

    # ----------------------------------
    subcode: check_file_scope
        $(set:da=$1,$1_len,$1_size)
        i_file_scope_save=-1
        $if cv->i_file != cur_file_scope
            i_file_scope_save = cur_file_scope
            $local struct call_stack_entry cur_stack_save
            cur_stack_save = $(da:g_local)

            cur_file_scope = cv->i_file
            $(da:g_local) = g_file_scopes[cur_file_scope]
            $call @debug_file_scope

        &call check_cv_scope
            BLOCK

        $if i_file_scope_save>=0
            cur_file_scope = i_file_scope_save
            $(da:g_local) = cur_stack_save
            $call @debug_file_scope

    subcode: check_cv_scope
        n_save = 0
        $if cv->i_start + cv->n_vars > g_local_len
            n_save = g_local_len - cv->i_start
        $else
            n_save = cv->n_vars
        # $print "save cv_scope @%d + %d",cv->i_start,n_save
        $if n_save > 0
            sv_local = g_local+cv->i_start
            $allocate(n_save) sv_save
            memcpy(sv_save,sv_local, n_save*$(sv_size))
        BLOCK
        $if n_save
            memcpy(sv_local,sv_save, n_save*$(sv_size))

    # ---------------------
    subcode: set_I_at_ARG(av)
        $(set:av_arg=g_global[I_at_ARG].value.p)
        av_save = $(av_arg)
        $call setup_args
        BLOCK
        $(av_arg) = av_save

        subcode: setup_args
            $if !sv_arg
                $(av_arg) = NULL
            $elif sv_arg->type==SVt_av
                SV_copy(&g_global[I_at_ARG], sv_arg)
                $call ret_svreg, sv_arg
            $else
                $(av_arg) = AV_new()
                AV_push($(av_arg), sv_arg)
                $call ret_svreg, sv_arg

            g_global[I_at_RET].value.p = NULL

    # ---------------------
    subcode: get_returns
        AV_free(g_global[I_at_ARG].value.p)

        av_ret = (struct AV*)g_global[I_at_RET].value.p
        $if av_ret
            $if $(IS_LIST)
                sv_ret = get_svreg(SVt_av)
                $call sv_set_p, sv_ret, av_ret, _
            $else
                sv_ret = AV_shift(av_ret)
                AV_free(av_ret)
        $else
            sv_ret = NULL

#----------------------------------------------- 
subcode:: eval_op_cases
    case OP_RETURN:
        # simply clear @_ and put returns there
        $(set:av_ret=g_global[I_at_RET].value.p)
        sv_ret = eval_op(op->right.op, $(CTX_LIST))
        $if !sv_ret
            $(av_ret)=NULL
        $elif sv_ret->type==SVt_av
            $(av_ret)=$(sv_av:sv_ret)
            sv_ret->value.p = NULL
            $call ret_svreg, sv_ret
        $else
            av_ret = AV_new()
            AV_push(av_ret, sv_ret)
            $(av_ret) = av_ret
            $call ret_svreg, sv_ret
        # set sv_ret to OP_GOTO 
        sv_ret=get_svreg(SVt_undef)
        cv = op->left.cv
        $call sv_set_goto, sv_ret, cv, GOTO_return
        return sv_ret



