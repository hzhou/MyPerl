macros:
    CTX: tn_context, tn_level+1
    CTX_VOID: 0, tn_level+1
    CTX_SCALAR: 1, tn_level+1
    CTX_LIST: 2, tn_level+1
    CTX_LEFT: 3, tn_level+1

    IS_VOID: tn_context==0
    IS_SCALAR: tn_context==1
    IS_LIST: tn_context==2
    IS_LEFT: tn_context==3

    PARAM_CTX: tn_context, tn_level

fncode: eval_op
    $parameter op, $(PARAM_CTX)
    $return_type struct SV*
    $(set:opT=op->type==OP_$1)
    $(set:L=op->left.op)
    $(set:R=op->right.op)

    $if !op
        return NULL
    $call @debug_eval_op
    switch(op->type){
        case OP_NOOP:
            return NULL
        case OP_SEQ:
            eval_op($(L), 0, tn_level)
            return eval_op($(R), 0, tn_level)
        case OP_LIST:
            f_flatten_op_list(op, OP_LIST, OP_list)
        case OP_list:
            $if $(IS_SCALAR)
                # (...,list) always means list
                return eval_list(op, $(CTX_LIST))
            $else
                return eval_list(op, $(CTX))
        case OP_CV:
            return run_cv(op->right.cv, $(CTX))
        case OP_CONST:
            return SV_copy(NULL, op->right.sv)
            # return op->right.sv
        $call @eval_op_cases
        default:
            $call @eval_op_group
            break    
    }
    $call die, "unsupported op: %s", get_OP_name(op->type)
    return NULL

#----------------------------------------------- 
subcode:: define_ops
    $map define_op, list

fncode: eval_list
    $parameter op, $(PARAM_CTX)
    $call get_av_reg, sv, av
    $if !op
        return sv

    $if op->type==OP_list
        n=op->left.n
    $else
        n=1

    op_list = op->right.op
    # $print "eval_list: $n items"
    $for i=0:n
        sv_item = eval_op(&op_list[i], $(CTX))
        $call av_push, av, sv_item
        $call ret_svreg, sv_item
    return sv


fncode: eval_list_old
    $parameter op_a, op_b, $(PARAM_CTX)
    # $print "eval_list %p, %p", op_a, op_b
    $if $(IS_LEFT)
        NOOP
    $else
        tn_context = 2
    sv_b = eval_op(op_b, $(CTX))
    $if !op_a
        $if sv_b->type == SVt_av
            return sv_b
        $else
            $call get_av_reg, sv, av
    $else
        sv_a = eval_op(op_a, $(CTX))
        $if $(sv_is_reg:sv_a) && sv_a->type==SVt_av
            sv = sv_a
            av = $(sv_av:sv)
        $else
            $call get_av_reg, sv, av
            # $print "new sv av: %p - %p", sv, av
            $call av_push, av, sv_a
            $call ret_svreg, sv_a

    $call av_push, av, sv_b
    $call ret_svreg, sv_b
    return sv

subcode: av_push(av_list, sv_item)
    $if $(sv_item) && $(sv_item)->type==SVt_av
        av_item = $(sv_av:$(sv_item))
        $call assert, av_item!=av
        &call av_each, av_item
            AV_push($(av_list), $(sv))
    $else
        AV_push($(av_list), $(sv_item))

