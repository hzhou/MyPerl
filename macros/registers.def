#----- registers -----------------
macros:
    N_REGS: 100
    DEBUG_registers: 0

subcode: _autoload
    $global struct SV svregs[$(N_REGS)], i_svreg=0, n_svreg=0

# register does not participate ref counting
#    sole owner of its content, so refcnt===1
#    you can't take reference of registers anyway
fncode: get_svreg(tn_type)
    $return_type struct SV*
    $if n_svreg>=$(N_REGS)
        $call die, "Out of SV registers!"

    $while svregs[i_svreg].flag
        $call inc_i_svreg

    sv= &svregs[i_svreg]
    $call _init
    n_svreg++
    $(if:debug_registers)
        $print "get_svreg $i_svreg/$n_svreg"
    return sv

    subcode: inc_i_svreg
        i_svreg=(i_svreg+1)%$(N_REGS)

    subcode: _init
        sv->flag = SVf_register
        $call sv_init, sv, tn_type

subcode: ret_svreg(sv)
    SV_refdec($(sv))

subcode: ret_svreg_borrow(sv)
    # when its content (av or string) been taken
    $if $(sv) && $(sv_is_reg:$(sv))
        $(sv)->flag = 0
        n_svreg--
#----------------------------------------------- 
subcode:: sv_release
    $case $(sv_is_reg:sv)
        sv->flag = 0
        n_svreg--
        $(if:debug_registers)
            $print "  ret_svreg %d/$n_svreg", (int)(sv-svregs)

#----------------------------------------------- 
#- convenience
subcode: get_string_reg(sv)
    $(sv) = get_svreg(SVt_string)
    $(sv)->value.S.s=NULL
    $(sv)->value.S.n=0
    $(sv)->value.S.size=0

subcode: get_av_reg(sv, av)
    $(sv) = get_svreg(SVt_av)
    $(av) = AV_new()
    $call sv_set_p, $(sv), $(av), _

subcode: get_hv_reg(sv, hv)
    $(sv) = get_svreg(SVt_hv)
    $(hv) = HV_new()
    $call sv_set_p, $(sv), $(hv), _

