include: macros/sv_string.def

macros:
    SV_UNION:: n, f, struct STRING S, void* p
    SV_UNION:: struct INTEGER N, struct FLOAT F

subcode: _autoload
    $call @define_sv_types
    $struct(SV) char type, char flag, int refcnt, union value
    $union $(SV_UNION)

    #- const: e.g. part of OP code (literal const)
    #- register: get_svreg(), holds intermediate
    #- varable: our or my, require persistency
    $define(SVf_const) 0
    $define(SVf_register) 1
    $define(SVf_var) 2
    $(block:main_init)
        $global sv_TRUE, sv_FALSE
        $(for:TRUE,FALSE)
            sv_$1 = get_sv()
            sv_$1->refcnt = -1
        $call sv_set_n, sv_TRUE, 1
        $call sv_set_n, sv_FALSE, 0

subcode:: define_sv_types
    $register_prefix(sv) struct SV*
    $register_prefix(av) struct AV*
    $register_prefix(hv) struct HV*
    $register_prefix(cv) struct CV*
    $register_prefix(io) FILE *

    $register_name(f) double
    $register_prefix(f) double

    $global char* SV_names[]={DUMP_STUB SV_names}
    $(block:SV_names)
        "NULL",
    $map define_sv_type, int, float, number
    $map define_sv_type, const, string, integer, fixed
    $map define_sv_type, sv, av, hv, cv, io

    subcode: define_sv_type(T)
        $(setmacro:_sv_type+=1)
        $define(SVt_$(T)) $(_sv_type)
        $(block:SV_names)
            "SVt_$(T)",

subcode:: define_sv_types
    $struct(STRING) s, n, size
    $struct(INTEGER) uint64_t* p, char sign, short n, size
    $struct(FLOAT) f, f_eps
    $struct(COMPLEX) f_r, f_i

fncode: get_SV_name(n_type)
    return SV_names[n_type]

macros: 
    sv_size: sizeof(struct SV)
    sv_is_reg: ($1->flag&3)==SVf_register
    sv_is_const: ($1->flag&3)==SVf_const
    sv_is_var: ($1->flag&3)==SVf_var
    
#----------------------------------------------- 
subcode: sv_set_n(sv, n)
    $(sv)->type = SVt_int
    $(sv)->value.n=$(n)

subcode: sv_set_f(sv, f)
    $(sv)->type = SVt_float
    $(sv)->value.f=$(f)

# -------------------------------------
fncode: SV_set_p(sv, void* p, int type)
    sv->type = type
    sv->value.p=p

#---- Ref Counting -------------------------- 
fncode: SV_refinc(sv)
    sv->refcnt++

fncode: SV_refdec(sv)
    # $print "SV_refdec %p - %d", sv, sv->refcnt
    $if sv->refcnt>0
        sv->refcnt--
        $if sv->refcnt==0
            $(set:T=sv->type==SVt_$1)
            $call @sv_ref_release
            $if sv->type == SVt_string && sv->value.S.size>0
                free(sv->value.S.s)
            $elif sv->type == SVt_sv
                SV_refdec((struct SV*)sv->value.p)
            $elif sv->type == SVt_av
                AV_free((struct AV*)sv->value.p)
            $elif sv->type == SVt_hv
                HV_free((struct HV*)sv->value.p)
            $elif sv->type == SVt_io
                fclose((FILE*)sv->value.p)

macros:
    sv_av: (struct AV*)$1->value.p
    sv_hv: (struct HV*)$1->value.p
    
