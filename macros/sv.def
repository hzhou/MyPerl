subcode: _autoload
    $register_prefix(sv) struct SV*
    $register_prefix(av) struct AV*
    $register_prefix(hv) struct HV*
    $register_prefix(cv) struct CV*
    $register_prefix(io) FILE *

    $struct(STRING) s, int len, int size
    $struct(SV) char type, char flag, int refcnt, union value
    $union n, double f, struct STRING S, void* p

    $map define_sv_type, int, float, number
    $map define_sv_type, const, string, 
    $map define_sv_type, sv, av, hv, cv, io

    #- const: e.g. part of OP code (literal const)
    #- register: get_svreg(), holds intermediate
    #- varable: our or my, require persistency
    $define(SVf_const) 0
    $define(SVf_reg) 1
    $define(SVf_var) 2
macros: 
    sv_is_reg: $1&3==SVf_reg
    sv_is_const: $1&3==SVf_const
    sv_is_var: $1&3==SVf_var
    
subcode: define_sv_type(T)
    $(setmacro:_sv_type+=1)
    $define(SVt_$(T)) $(_sv_type)

#----------------------------------------------- 
subcode: sv_set_n(sv, n)
    $(sv)->type = SVt_int
    $(sv)->value.n=$(n)

subcode: sv_set_f(sv, f)
    $(sv)->type = SVt_float
    $(sv)->value.f=$(f)

fncode: SV_set_const(sv, s, n)
    # I am not sure if we need this at all
    # .size=0, do not free
    $if n==0
        n=strlen(s)
    sv->type = SVt_const
    sv->value.S.s=s
    sv->value.S.len=n
    
fncode: SV_copy_s(sv, s, n)
    $if n==0
        n=strlen(s)
    sv->type = SVt_string
    $allocate(n+1) sv->value.S.s
    memcpy(sv->value.S.s, s, n)
    sv->value.S.len = n
    sv->value.S.size= n+1

subcode: if_sv_string(sv)
    $if $(sv) && $(sv)->type==SVt_string
        $(set:s=$(sv)->value.S.s)
        $(set:n=$(sv)->value.S.len)
        BLOCK

# -------------------------------------
fncode: SV_set_p(sv, void* p, int type)
    sv->type = type
    sv->value.p=p

#---- Ref Counting -------------------------- 
fncode: SV_refinc(sv)
    sv->refcnt++

fncode: SV_refdec(sv)
    sv->refcnt--
    $if sv->refcnt==0
        $if sv->type == SVt_string && sv->value.S.size>0
            free(sv->value.S.s)
        $elif sv->type == SVt_sv
            SV_refdec((struct SV*)sv->value.p)
        $elif sv->type == SVt_av
            AV_free((struct AV*)sv->value.p)
        $elif sv->type == SVt_hv
            HV_free((struct HV*)sv->value.p)
        $elif sv->type == SVt_io
            fclose((FILE*)sv->value.p)

#---- String ---------------------------
fncode: SV_resize(sv, n)
    $call assert, sv->type==SVt_string
    $(set:S=sv->value.S)
    $if n==0
        n=$(S).size*5/3+20

    $if n>$(S).size
        $(S).s = realloc($(S).s, n)
        $(S).size = n

fncode: SV_append_s(sv, s, n)
    $call assert, sv->type==SVt_string
    $(set:S=sv->value.S)
    SV_resize(sv, $(S).len+n)
    memcpy($(S).s+$(S).len, s, n)
    $(S).len+=n

fncode: SV_append_i(sv, i)
    $call assert, sv->type==SVt_string
    $(set:S=sv->value.S)
    SV_resize(sv, $(S).len+30)
    n=sprintf($(S).s+$(S).len, "%d", i)
    $(S).len+=n

fncode: SV_append_f(sv, double f)
    $call assert, sv->type==SVt_string
    $(set:S=sv->value.S)
    SV_resize(sv, $(S).len+30)
    n=sprintf($(S).s+$(S).len, "%.8g", f)
    $(S).len+=n

#----- conversions ----------------
#--      sv to number 
subcode: sv_int(sv, n)
    $if $(sv)->type == SVt_int
        $(n) = $(sv)->value.n
    $elif $(sv)->type == SVt_float
        $(n) = (int)$(sv)->value.f
    $(if:!skip_string)
        $elif $(sv)->type == SVt_string
            $(n) = sv_string_int($(sv))
    $else
        $(n) = 0

subcode: sv_float(sv, f)
    $if $(sv)->type == SVt_int
        $(f) = (double)$(sv)->value.n
    $elif $(sv)->type == SVt_float
        $(f) = $(sv)->value.f
    $(if:!skip_string)
        $elif $(sv)->type == SVt_string
            $(f) = sv_string_float($(sv))
    $else
        $(f) = 0.0

#-- string to number
fncode: sv_string_int(sv)
    $call fn_string_number, n

fncode: sv_string_float(sv)
    $call fn_string_number, f

subcode: fn_string_number(n)
    sv_tmp=get_svreg()
    $(set:S=sv->value.S)
    $(S).s[$(S).len]='\0'
    f_get_number($(S).s, sv_tmp)

    $(set:skip_string=1)
    $(if:n=n)
        $local n
        $call sv_int, sv_tmp, n
    $(elif:n=f)
        $local double f
        $call sv_float, sv_tmp, f

    $call ret_svreg, sv_tmp
    return $(n)

